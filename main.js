// Generated by CoffeeScript 1.4.0
(function() {
  var fs, np;

  fs = require('fs');

  np = require('path');

  exports.watchDirectory = function(dirname, options, listener) {
    var filter, fsListener, initial, notifyListener, unwatchFile, watchFile, watchedFiles, _ref, _ref1, _ref2, _ref3;
    if (!(listener != null)) {
      listener = options;
      options = {};
    }
    if ((_ref = options.persistent) == null) {
      options.persistent = true;
    }
    if ((_ref1 = options.interval) == null) {
      options.interval = 100;
    }
    if ((_ref2 = options.recursive) == null) {
      options.recursive = true;
    }
    if ((_ref3 = options.initial) == null) {
      options.initial = 'initial';
    }
    filter = function(name) {
      var ext;
      if (!(options.filter != null)) {
        return true;
      } else if (typeof options.filter === 'string') {
        ext = options.filter;
        return name.indexOf(ext, name.length - ext.length) !== -1;
      } else if (options.filter.constructor === RegExp) {
        return options.filter.test(name);
      } else if (typeof options.filter === 'function') {
        return options.filter(name);
      } else {
        throw new Error("Invalid filter value: " + options.filter);
      }
    };
    watchedFiles = {};
    notifyListener = function(filename, curr, prev, change) {
      if (filter(filename)) {
        return listener(filename, curr, prev, change);
      }
    };
    fsListener = function(filename, depth, curr, prev) {
      var change;
      change = curr.nlink === 0 ? 'deleted' : prev.nlink === 0 ? 'created' : 'modified';
      notifyListener(filename, curr, prev, change);
      if (change !== 'deleted') {
        return watchFile(filename, depth, curr);
      } else {
        return unwatchFile(filename);
      }
    };
    unwatchFile = function(filename) {
      fs.unwatchFile(filename, watchedFiles[filename]);
      return delete watchedFiles[filename];
    };
    watchFile = function(filename, depth, stats) {
      var boundListener, child, _i, _len, _ref4;
      if (depth == null) {
        depth = 0;
      }
      if (stats == null) {
        stats = fs.statSync(filename);
      }
      if (stats.nlink > 0) {
        if (stats.isDirectory()) {
          if (depth === 0 || options.recursive) {
            _ref4 = fs.readdirSync(filename);
            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
              child = _ref4[_i];
              child = np.join(filename, child);
              watchFile(child, depth + 1);
            }
          }
        }
        if (!(watchedFiles[filename] != null)) {
          boundListener = fsListener.bind(this, filename, depth);
          watchedFiles[filename] = boundListener;
          fs.watchFile(filename, boundListener);
          if (initial) {
            notifyListener(filename, stats, stats, initial);
          }
        }
      }
    };
    initial = options.initial;
    watchFile(dirname);
    initial = 'created';
    return function() {
      var key, _results;
      _results = [];
      for (key in watchedFiles) {
        _results.push(unwatchFile(key));
      }
      return _results;
    };
  };

}).call(this);
